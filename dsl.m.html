<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>phi.dsl API documentation</title>
    <meta name="description" content="The Phi DSL is all about combining functions in useful ways, enabling a declarative approach that ca..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#phi.dsl.Compile">Compile</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Branch">Branch</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Branch.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.CompilationContextManager">CompilationContextManager</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.CompilationContextManager.__init__">__init__</a></li>
    <li class="mono"><a href="#phi.dsl.CompilationContextManager.get_ref">get_ref</a></li>
    <li class="mono"><a href="#phi.dsl.CompilationContextManager.set_ref">set_ref</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Composition">Composition</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Composition.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Function">Function</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Function.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.If">If</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.If.__init__">__init__</a></li>
    <li class="mono"><a href="#phi.dsl.If.Else">Else</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Input">Input</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Input.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Node">Node</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Read">Read</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Read.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Record">Record</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Record.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Ref">Ref</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Ref.__init__">__init__</a></li>
    <li class="mono"><a href="#phi.dsl.Ref.set">set</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.With">With</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.With.__init__">__init__</a></li>
    <li class="mono"><a href="#phi.dsl.With.set_scope">set_scope</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#phi.dsl.Write">Write</a></span>
        
          
  <ul>
    <li class="mono"><a href="#phi.dsl.Write.__init__">__init__</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">phi.dsl</span> module</h1>
  <p>The Phi DSL is all about combining functions in useful ways, enabling a declarative approach that can improve clarity, readability and lead to shorter code. All valid expression of the DSL can be compiled to a function using <code>P.Make</code> or applied to a value using <code>P.Pipe</code>.</p>
<p>Phi offers the following constructs/expressions, <strong>try to read their documentation in order</strong>:</p>
<ul>
<li><strong><a href="#phi.dsl.Function"><code>Function</code></a></strong>: any function of arity 1 is an element of the language</li>
<li><strong><a href="#phi.dsl.Composition"><code>Composition</code></a></strong>: allows to sequentially compose functions</li>
<li><strong><a href="#phi.dsl.Branch"><code>Branch</code></a></strong>: lets to create a branched computation that returns a list with the results of each branch</li>
<li><strong><a href="#phi.dsl.Input"><code>Input</code></a></strong>: allows you to specify an input value, compiles to a (constant) function that returns the same value no matter the input</li>
<li><strong><a href="#phi.dsl.With"><code>With</code></a></strong>: lets you to specify a context manager for the expresion (uses the <code>with</code> statemente)</li>
<li><strong><a href="#phi.dsl.Record"><code>Record</code></a></strong>: lets to create a branched computation with named branches that returns a record-like structure with the results of each branch</li>
<li><strong><a href="#phi.dsl.Read"><code>Read</code></a> &amp; <a href="#phi.dsl.Write"><code>Write</code></a></strong>: allow you to create a reference to the value at some point and read it latter on.F</li>
</ul>
<p>Any expresion can appear inside any other expresion in a nested fasion. They correct way to think about this is that each sub-expression will be compiled to a function of arity 1, therefore from the parent expresion's point of view all of its elements are just functions.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The Phi DSL is all about combining functions in useful ways, enabling a declarative approach that can improve clarity, readability and lead to shorter code. All valid expression of the DSL can be compiled to a function using `P.Make` or applied to a value using `P.Pipe`.</span>

<span class="sd">Phi offers the following constructs/expressions, **try to read their documentation in order**:</span>

<span class="sd">* **`phi.dsl.Function`**: any function of arity 1 is an element of the language</span>
<span class="sd">* **`phi.dsl.Composition`**: allows to sequentially compose functions</span>
<span class="sd">* **`phi.dsl.Branch`**: lets to create a branched computation that returns a list with the results of each branch</span>
<span class="sd">* **`phi.dsl.Input`**: allows you to specify an input value, compiles to a (constant) function that returns the same value no matter the input</span>
<span class="sd">* **`phi.dsl.With`**: lets you to specify a context manager for the expresion (uses the `with` statemente)</span>
<span class="sd">* **`phi.dsl.Record`**: lets to create a branched computation with named branches that returns a record-like structure with the results of each branch</span>
<span class="sd">* **`phi.dsl.Read` &amp; `phi.dsl.Write`**: allow you to create a reference to the value at some point and read it latter on.F</span>

<span class="sd">Any expresion can appear inside any other expresion in a nested fasion. They correct way to think about this is that each sub-expression will be compiled to a function of arity 1, therefore from the parent expresion&#39;s point of view all of its elements are just functions.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">identity</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>
<span class="kn">import</span> <span class="nn">functools</span>


<span class="c1">###############################</span>
<span class="c1"># Helpers</span>
<span class="c1">###############################</span>

<span class="k">class</span> <span class="nc">_NoValue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;NoValue&quot;</span>

<span class="n">_NO_VALUE</span> <span class="o">=</span> <span class="n">_NoValue</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Ref</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for Ref.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">_NO_VALUE</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Ref</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">optional</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">_NO_VALUE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Trying to read Ref(&#39;{0}&#39;) before assignment&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">x</span>


<span class="k">class</span> <span class="nc">CompilationContextManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="n">_NO_VALUE</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_refs</span><span class="p">,</span> <span class="n">next_with_global_context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_refs</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_refs</span> <span class="o">=</span> <span class="n">next_refs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">previous_with_global_context</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_with_global_context</span> <span class="o">=</span> <span class="n">next_with_global_context</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_refs</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_with_global_context</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_refs</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_with_global_context</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="c1">#Copy to avoid stateful behaviour</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">:</span>
            <span class="n">other_ref</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="c1"># merge state: borg pattern</span>
            <span class="n">other_ref</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_ref</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>



<span class="k">class</span> <span class="nc">_RecordObject</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for DictObject.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">unicode</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">))</span>

<span class="c1">###############################</span>
<span class="c1"># DSL Elements</span>
<span class="c1">###############################</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for Node.&quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">All basic/terminal elements of this language are callables (implement `__call__`) of arity 1.</span>

<span class="sd">### Examples</span>
<span class="sd">Compiling a function just returns back the function</span>

<span class="sd">    Make(f) == f</span>

<span class="sd">and piping through a function is just the same a applying the function</span>

<span class="sd">    P.Pipe(x, f) == f(x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_f</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">=</span> <span class="n">_f</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Fun({0})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">)</span>


<span class="n">_Identity</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Branch</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">While `Composition` is sequential, `Branch` allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements `__iter__`) that is not a tuple and yields a valid expresion.</span>

<span class="sd">After compilation the expresion:</span>

<span class="sd">    k = [f, g]</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = [ f(x), g(x) ]</span>


<span class="sd">In general, the following rules apply after compilation:</span>

<span class="sd">**General Branching**</span>

<span class="sd">    let fs = &lt;some iterable of valid expressions&gt;</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = [ f(x) for f in fs ]</span>


<span class="sd">**Composing &amp; Branching**</span>

<span class="sd">A more common scenario however is to see how braching interacts with composing. The expression</span>

<span class="sd">    k = (f, [g, h])</span>

<span class="sd">is *almost* equivalent to</span>

<span class="sd">    k = [ (f, g), (f, h) ]</span>

<span class="sd">As you see its as if `f` where distributed over the list. We say *almost* because what really happens is that the iterable is first compiled to a function and the whole sequence is then composed</span>

<span class="sd">     z(x) = [ g(x), h(x) ]</span>
<span class="sd">     k(x) = (f, z)(x) = z(f(x))</span>

<span class="sd">As you see `f` is only excecuted once.</span>

<span class="sd">### Examples</span>

<span class="sd">    form phi import P</span>

<span class="sd">    avg_word_length = P.Pipe(</span>
<span class="sd">        &quot;1 22 333&quot;,</span>
<span class="sd">        lambda s: s.split(&#39; &#39;), # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">        lambda l: map(len, l), # [1, 2, 3]</span>
<span class="sd">        [</span>
<span class="sd">            sum # 1 + 2 + 3 == 6</span>
<span class="sd">        ,</span>
<span class="sd">            len # len([1, 2, 3]) == 3</span>
<span class="sd">        ],</span>
<span class="sd">        lambda l: l[0] / l[1] # sum / len == 6 / 3 == 2</span>
<span class="sd">    )</span>

<span class="sd">    assert avg_word_length == 2</span>

<span class="sd">The previous could also be done more briefly like this</span>

<span class="sd">    form phi import P, Obj</span>

<span class="sd">    avg_word_length = P.Pipe(</span>
<span class="sd">        &quot;1 22 333&quot;,</span>
<span class="sd">        Obj.split(&#39; &#39;), # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">        P.map(len), # [1, 2, 3]</span>
<span class="sd">        [</span>
<span class="sd">            sum # sum([1, 2, 3]) == 6</span>
<span class="sd">        ,</span>
<span class="sd">            len # len([1, 2, 3]) == 3</span>
<span class="sd">        ],</span>
<span class="sd">        P[0] / P[1] # 6 / 3 == 2</span>
<span class="sd">    )</span>

<span class="sd">    assert avg_word_length == 2</span>

<span class="sd">In the example above the last expression</span>

<span class="sd">    P[0] / P[1]</span>

<span class="sd">works for a couple of reasons</span>

<span class="sd">1. The previous expression returns a list</span>
<span class="sd">2. In general the expression `P[x]` compiles to a function with the form `lambda obj: obj[x]`</span>
<span class="sd">3. The class `Lambda` (the class from which the object `P` inherits) overrides most operators to create functions easily. For example, the expression</span>

<span class="sd">    (P * 2) / (P + 1)</span>

<span class="sd">compile to a function of the form</span>

<span class="sd">    f(x) = (x * 2) / (x + 1)</span>

<span class="sd">Check out the documentatio for Phi [lambdas](https://cgarciae.github.io/phi/lambdas.m.html).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable_code</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">iterable_code</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">_reduce_branches</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="p">[])</span>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reduce_branches</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Write</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">branches</span> <span class="o">+</span> <span class="p">[</span> <span class="n">b</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># type(b) is Write</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">branches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">branches</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="n">seq</span> <span class="p">]</span>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">iterable_code</span><span class="p">):</span>

        <span class="n">iterable_code</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable_code</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">iterable_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
            <span class="n">node_f</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_f</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span> <span class="p">]</span>

        <span class="k">return</span> <span class="n">function</span>


<span class="k">class</span> <span class="nc">Composition</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">In this language tuples are used to express function composition. After compilation, the expression</span>

<span class="sd">    k = (f, g)</span>

<span class="sd">be equivalent to</span>

<span class="sd">    k(x) = g(f(x))</span>

<span class="sd">As you see, its a little different from the mathematical definition. Excecution order flow from left to right, and this makes reading and reasoning about code structured in the way more easy. This bahaviour is based upon the `|&gt;` (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</span>

<span class="sd">In general, the following rules apply after compilation:</span>

<span class="sd">**General Sequence**</span>

<span class="sd">    k = (f0, f1, ..., fn-1, fn)</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = fn(fn-1(...(f1(f0(x)))))</span>

<span class="sd">**Single Function**</span>

<span class="sd">    k = (f)</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k = f</span>

<span class="sd">**Identity**</span>

<span class="sd">The empty tuple</span>

<span class="sd">    k = ()</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = x</span>

<span class="sd">### Examples</span>

<span class="sd">    from phi import P</span>

<span class="sd">    f = Make(</span>
<span class="sd">        lambda x: x * 2,</span>
<span class="sd">        lambda x: x + 1,</span>
<span class="sd">        lambda x: x ** 2</span>
<span class="sd">    )</span>

<span class="sd">    assert f(1) == 9 # ((1 * 2) + 1) ** 2</span>

<span class="sd">As you see, `Make`s `*args` are interpreted as a tuple which means all expressions contained are composed. The previous example using `P.Pipe`</span>

<span class="sd">    from phi import P</span>

<span class="sd">    assert 9 == P.Pipe(</span>
<span class="sd">        1,</span>
<span class="sd">        lambda x: x * 2,</span>
<span class="sd">        lambda x: x + 1,</span>
<span class="sd">        lambda x: x ** 2</span>
<span class="sd">    )</span>

<span class="sd">Again, `Pipe`&#39;s signature is `Pipe(x, *args)` and `*args` is interpreted as a tuple which means all expressions contained are composed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_code</span><span class="p">,</span> <span class="n">right_code</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Composition</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">left_code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">right_code</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__build__</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">prevs</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">prevs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Composition</span><span class="o">.</span><span class="n">__build__</span><span class="p">(</span><span class="o">*</span><span class="n">prevs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Composition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">):</span>
        <span class="n">tuple_code</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Identity</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_parse</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">tuple_code</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Composition</span><span class="o">.</span><span class="n">__build__</span><span class="p">(</span><span class="o">*</span><span class="n">tuple_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="n">f_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compose2</span><span class="p">(</span><span class="n">f_right</span><span class="p">,</span> <span class="n">f_left</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Seq({0}, {1})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Record</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">List or iterables in general provide you a way to branch your computation in the DSL, but access to the values of each branch are then done by index, this might be a little inconvenient because it reduces readability. Record branches provide a way to create named branches via a dictionary object where the keys are the names of the branches and the values are valid expressions representing the computation of that branch.</span>

<span class="sd">A special object is returned by this expression when excecuted, this object derives from `dict` and fully emulates it so you can treat it as such, however it also implements the `__getattr__` method, this lets you access a value as if it where a field if its key is a of type string.</span>

<span class="sd">### Examples</span>

<span class="sd">    from phi import P</span>

<span class="sd">    stats = P.Pipe(</span>
<span class="sd">        [1,2,3],</span>
<span class="sd">        dict(</span>
<span class="sd">            sum = sum</span>
<span class="sd">        ,</span>
<span class="sd">            len = len</span>
<span class="sd">        )</span>
<span class="sd">    )</span>

<span class="sd">    assert stats.sum == 6</span>
<span class="sd">    assert stats.len == 3</span>

<span class="sd">    assert stats[&#39;sum&#39;] == 6</span>
<span class="sd">    assert stats[&#39;len&#39;] == 3</span>

<span class="sd">Now lets image that we want to find the average value of the list, we could calculate it outside of the pipe doing something like `avg = stats.sum / stats.len`, however we could also do it inside the pipe using `P.Rec` or `phi.Rec` like this</span>

<span class="sd">    from phi import P, Rec</span>

<span class="sd">    avg = P.Pipe(</span>
<span class="sd">        [1,2,3],</span>
<span class="sd">        dict(</span>
<span class="sd">            sum = sum</span>
<span class="sd">        ,</span>
<span class="sd">            len = len</span>
<span class="sd">        ),</span>
<span class="sd">        Rec.sum / Rec.len</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_code</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Record</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">dict_code</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">dict_code</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Record</span><span class="p">(</span><span class="n">dict_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">funs_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

            <span class="n">funs_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_RecordObject</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">})</span>

        <span class="k">return</span> <span class="n">function</span>



<span class="k">class</span> <span class="nc">With</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**With**</span>

<span class="sd">    def With(context_manager, *body):</span>

<span class="sd">**Arguments**</span>

<span class="sd">* **context_manager**: a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) object or valid expression from the DSL that returns a context manager.</span>
<span class="sd">* ***body**: any valid expression of the DSL to be evaluated inside the context. `*body` is interpreted as a tuple so all expression contained are composed.</span>

<span class="sd">As with normal python programs you sometimes might want to create a context for a block of code. You normally give a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) to the [with](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement) statemente, in Phi you use `P.With` or `phi.With`</span>

<span class="sd">**Context**</span>

<span class="sd">Python&#39;s `with` statemente returns a context object through `as` keyword, in the DSL this object can be obtained using the `P.Context` method or the `phi.Context` function.</span>

<span class="sd">### Examples</span>

<span class="sd">    from phi import P, Obj, Context, With, Pipe</span>

<span class="sd">    text = Pipe(</span>
<span class="sd">        &quot;text.txt&quot;,</span>
<span class="sd">        With( open, Context,</span>
<span class="sd">            Obj.read()</span>
<span class="sd">        )</span>
<span class="sd">    )</span>

<span class="sd">The previous is equivalent to</span>

<span class="sd">    with open(&quot;text.txt&quot;) as f:</span>
<span class="sd">        text = f.read()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope_code</span><span class="p">,</span> <span class="o">*</span><span class="n">body_code</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">With</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">scope_code</span><span class="p">,</span> <span class="n">else_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">body_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">scope_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
        <span class="n">body_fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">scope_f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">as</span> <span class="n">scope</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">body_fs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">function</span>

    <span class="k">def</span> <span class="nf">set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_scope</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span> <span class="o">=</span> <span class="n">new_scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_scope</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_scope</span>


<span class="k">class</span> <span class="nc">Read</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Giving names and saving parts of your computation to use then latter is useful to say the least. In the DSL the expression</span>

<span class="sd">    {&#39;x&#39;}</span>

<span class="sd">behaves like just like the indentity except that as a side effect it creates a reference to that value which you can call latter. Here `{..}` is python&#39;s sytax for a set literal and `x` is a string with the name of the reference. To read the previous you would use the expression</span>

<span class="sd">    &#39;x&#39;</span>

<span class="sd">This is equivalent to a sort of function like this</span>

<span class="sd">    lambda z: read(&#39;x&#39;)</span>

<span class="sd">where the input is totally ignored and a hypothetical `read` function is given the reference name and it should return its stored value (internally its not implemented like this). As you see strings in the DSL mean read from a reference and a set with a string means write to a reference.</span>

<span class="sd">### Example</span>
<span class="sd">Lets see a common situation where you would use this</span>

<span class="sd">    from phi import P</span>

<span class="sd">    P.Pipe(</span>
<span class="sd">        input,</span>
<span class="sd">        fun_1, {&#39;fun_1_val&#39;}</span>
<span class="sd">        fun_2,</span>
<span class="sd">        [</span>
<span class="sd">            fun_4</span>
<span class="sd">        ,</span>
<span class="sd">        (</span>
<span class="sd">            &#39;fun_1_val&#39;,</span>
<span class="sd">            fun_5</span>
<span class="sd">        )</span>
<span class="sd">        ]</span>
<span class="sd">    )</span>

<span class="sd">Here you *save* the value outputed by `fun_1` and the load it as the initial value of the second branch. In normal python the previous would be *almost* equivalent to this</span>

<span class="sd">    x = fun_1(input)</span>
<span class="sd">    fun_1_val = x</span>
<span class="sd">    x = fun_2(x)</span>
<span class="sd">    x = [</span>
<span class="sd">        fun_4(x)</span>
<span class="sd">    ,</span>
<span class="sd">        fun_5(fun_1_val)</span>
<span class="sd">    ]</span>

<span class="sd">    return x</span>

<span class="sd">### Write special case</span>
<span class="sd">When composing its aesthetically better to put writes in the same line as the function whos value its storing to make the intent a bit more clear:</span>

<span class="sd">    (</span>
<span class="sd">        f, {&#39;a&#39;},</span>
<span class="sd">        g</span>
<span class="sd">    )</span>

<span class="sd">Here we store the value of `f` in `&#39;a&#39;`, however, when you are inside a branch you will be tempted to do the following to get the same result:</span>

<span class="sd">    [</span>
<span class="sd">        f, {&#39;a&#39;}</span>
<span class="sd">    ,</span>
<span class="sd">        g</span>
<span class="sd">    ]</span>

<span class="sd">However, if you flatten the text you realize you actually have 3 branches instead of 2</span>

<span class="sd">    [ f, {&#39;a&#39;}, g ]</span>

<span class="sd">and that wont save the value of `f` in `&#39;a&#39;` as you intended. To avoid this possible error, the DSL rewrites the expression during parsing to</span>

<span class="sd">    [ ( f, {&#39;a&#39;} ), g ]</span>

<span class="sd">every time there is a write expression inside a branch expression.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Read</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">get_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">f</span>


<span class="k">class</span> <span class="nc">Write</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="n">Read</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Write</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Identity</span>

        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">code</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Ref</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parse Error: Sets can only contain strings or Refs, get {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>

        <span class="n">writes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">Write</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">code</span> <span class="p">])</span>
        <span class="k">return</span> <span class="n">_parse</span><span class="p">(</span><span class="n">writes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">Ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span>

            <span class="n">ref</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">set_ref</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">f</span>


<span class="k">class</span> <span class="nc">Input</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sometimes you might need to branch the computation but start one of the branches with a values different than the one being passed down, you could always solve it like this</span>

<span class="sd">    P.Pipe(</span>
<span class="sd">        ...,</span>
<span class="sd">        [</span>
<span class="sd">            lambda z: my_value</span>
<span class="sd">        ,</span>
<span class="sd">            ...</span>
<span class="sd">        ]</span>
<span class="sd">    )</span>

<span class="sd">Here we just made a lamda that took in the argument `z` but it was completely ignored and it always returns `my_value`, this is called a constant function. You could also do the same with `P.Val` or the top level function `phi.Val`</span>

<span class="sd">    from phi import P, Val</span>

<span class="sd">    P.Pipe(</span>
<span class="sd">        ...,</span>
<span class="sd">        [</span>
<span class="sd">            Val(my_value)</span>
<span class="sd">        ,</span>
<span class="sd">            ...</span>
<span class="sd">        ]</span>
<span class="sd">    )|</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">f</span>


<span class="k">class</span> <span class="nc">If</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for If.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">,</span> <span class="o">*</span><span class="n">Then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">Else</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Else&#39;</span><span class="p">,</span> <span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Predicate</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Predicate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Then</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Then</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Else</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Predicate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Predicate</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
        <span class="n">Then</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Then</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
        <span class="n">Else</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Then</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">Predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">Else</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">Else</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">Else</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Else</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>






<span class="c1">#######################</span>
<span class="c1">### FUNCTIONS</span>
<span class="c1">#######################</span>

<span class="k">def</span> <span class="nf">Compile</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">refs</span><span class="p">,</span> <span class="n">create_ref_context</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hola</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

    <span class="n">refs</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Ref</span> <span class="k">else</span> <span class="n">Ref</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">refs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">CompilationContextManager</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">_NoValue</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span> <span class="k">if</span> <span class="n">create_ref_context</span> <span class="k">else</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">else_input</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c1">#if type(code) is tuple:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">code</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isclass</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Function</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Read</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Write</span><span class="o">.</span><span class="n">__parse__</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Composition</span><span class="o">.</span><span class="n">__parse__</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Record</span><span class="o">.</span><span class="n">__parse__</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isclass</span><span class="p">(</span><span class="n">code</span><span class="p">):</span> <span class="c1">#leave last</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="o">.</span><span class="n">__parse__</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="c1">#its iterable</span>
    <span class="k">elif</span> <span class="n">else_input</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Input</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parse Error: Element not part of the DSL. Got: {0} of type {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">code</span><span class="p">)))</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="phi.dsl.Compile">
    <p>def <span class="ident">Compile</span>(</p><p>code, refs, create_ref_context=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Hola</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Compile', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Compile" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Compile</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">refs</span><span class="p">,</span> <span class="n">create_ref_context</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hola</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

    <span class="n">refs</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Ref</span> <span class="k">else</span> <span class="n">Ref</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">refs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">CompilationContextManager</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">_NoValue</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span> <span class="k">if</span> <span class="n">create_ref_context</span> <span class="k">else</span> <span class="n">f</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="phi.dsl.Branch" class="name">class <span class="ident">Branch</span></p>
      
  
    <div class="desc"><p>While <code>Composition</code> is sequential, <code>Branch</code> allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements <code>__iter__</code>) that is not a tuple and yields a valid expresion.</p>
<p>After compilation the expresion:</p>
<div class="codehilite"><pre><span></span>k = [f, g]
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k(x) = [ f(x), g(x) ]
</pre></div>


<p>In general, the following rules apply after compilation:</p>
<p><strong>General Branching</strong></p>
<div class="codehilite"><pre><span></span>let fs = &lt;some iterable of valid expressions&gt;
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k(x) = [ f(x) for f in fs ]
</pre></div>


<p><strong>Composing &amp; Branching</strong></p>
<p>A more common scenario however is to see how braching interacts with composing. The expression</p>
<div class="codehilite"><pre><span></span>k = (f, [g, h])
</pre></div>


<p>is <em>almost</em> equivalent to</p>
<div class="codehilite"><pre><span></span>k = [ (f, g), (f, h) ]
</pre></div>


<p>As you see its as if <code>f</code> where distributed over the list. We say <em>almost</em> because what really happens is that the iterable is first compiled to a function and the whole sequence is then composed</p>
<div class="codehilite"><pre><span></span> z(x) = [ g(x), h(x) ]
 k(x) = (f, z)(x) = z(f(x))
</pre></div>


<p>As you see <code>f</code> is only excecuted once.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="n">form</span> <span class="n">phi</span> <span class="kn">import</span> <span class="nn">P</span>

<span class="n">avg_word_length</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;1 22 333&quot;</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="c1"># [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="c1"># [1, 2, 3]</span>
    <span class="p">[</span>
        <span class="nb">sum</span> <span class="c1"># 1 + 2 + 3 == 6</span>
    <span class="p">,</span>
        <span class="nb">len</span> <span class="c1"># len([1, 2, 3]) == 3</span>
    <span class="p">],</span>
    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># sum / len == 6 / 3 == 2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">avg_word_length</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>The previous could also be done more briefly like this</p>
<div class="codehilite"><pre><span></span><span class="n">form</span> <span class="n">phi</span> <span class="kn">import</span> <span class="nn">P</span><span class="o">,</span> <span class="nn">Obj</span>

<span class="n">avg_word_length</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;1 22 333&quot;</span><span class="p">,</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="c1"># [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
    <span class="n">P</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">len</span><span class="p">),</span> <span class="c1"># [1, 2, 3]</span>
    <span class="p">[</span>
        <span class="nb">sum</span> <span class="c1"># sum([1, 2, 3]) == 6</span>
    <span class="p">,</span>
        <span class="nb">len</span> <span class="c1"># len([1, 2, 3]) == 3</span>
    <span class="p">],</span>
    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 6 / 3 == 2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">avg_word_length</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>In the example above the last expression</p>
<div class="codehilite"><pre><span></span>P[0] / P[1]
</pre></div>


<p>works for a couple of reasons</p>
<ol>
<li>The previous expression returns a list</li>
<li>In general the expression <code>P[x]</code> compiles to a function with the form <code>lambda obj: obj[x]</code></li>
<li>
<p>The class <code>Lambda</code> (the class from which the object <code>P</code> inherits) overrides most operators to create functions easily. For example, the expression</p>
<p>(P * 2) / (P + 1)</p>
</li>
</ol>
<p>compile to a function of the form</p>
<div class="codehilite"><pre><span></span>f(x) = (x * 2) / (x + 1)
</pre></div>


<p>Check out the documentatio for Phi <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Branch', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Branch" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Branch</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">While `Composition` is sequential, `Branch` allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements `__iter__`) that is not a tuple and yields a valid expresion.</span>

<span class="sd">After compilation the expresion:</span>

<span class="sd">    k = [f, g]</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = [ f(x), g(x) ]</span>


<span class="sd">In general, the following rules apply after compilation:</span>

<span class="sd">**General Branching**</span>

<span class="sd">    let fs = &lt;some iterable of valid expressions&gt;</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = [ f(x) for f in fs ]</span>


<span class="sd">**Composing &amp; Branching**</span>

<span class="sd">A more common scenario however is to see how braching interacts with composing. The expression</span>

<span class="sd">    k = (f, [g, h])</span>

<span class="sd">is *almost* equivalent to</span>

<span class="sd">    k = [ (f, g), (f, h) ]</span>

<span class="sd">As you see its as if `f` where distributed over the list. We say *almost* because what really happens is that the iterable is first compiled to a function and the whole sequence is then composed</span>

<span class="sd">     z(x) = [ g(x), h(x) ]</span>
<span class="sd">     k(x) = (f, z)(x) = z(f(x))</span>

<span class="sd">As you see `f` is only excecuted once.</span>

<span class="sd">### Examples</span>

<span class="sd">    form phi import P</span>

<span class="sd">    avg_word_length = P.Pipe(</span>
<span class="sd">        &quot;1 22 333&quot;,</span>
<span class="sd">        lambda s: s.split(&#39; &#39;), # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">        lambda l: map(len, l), # [1, 2, 3]</span>
<span class="sd">        [</span>
<span class="sd">            sum # 1 + 2 + 3 == 6</span>
<span class="sd">        ,</span>
<span class="sd">            len # len([1, 2, 3]) == 3</span>
<span class="sd">        ],</span>
<span class="sd">        lambda l: l[0] / l[1] # sum / len == 6 / 3 == 2</span>
<span class="sd">    )</span>

<span class="sd">    assert avg_word_length == 2</span>

<span class="sd">The previous could also be done more briefly like this</span>

<span class="sd">    form phi import P, Obj</span>

<span class="sd">    avg_word_length = P.Pipe(</span>
<span class="sd">        &quot;1 22 333&quot;,</span>
<span class="sd">        Obj.split(&#39; &#39;), # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">        P.map(len), # [1, 2, 3]</span>
<span class="sd">        [</span>
<span class="sd">            sum # sum([1, 2, 3]) == 6</span>
<span class="sd">        ,</span>
<span class="sd">            len # len([1, 2, 3]) == 3</span>
<span class="sd">        ],</span>
<span class="sd">        P[0] / P[1] # 6 / 3 == 2</span>
<span class="sd">    )</span>

<span class="sd">    assert avg_word_length == 2</span>

<span class="sd">In the example above the last expression</span>

<span class="sd">    P[0] / P[1]</span>

<span class="sd">works for a couple of reasons</span>

<span class="sd">1. The previous expression returns a list</span>
<span class="sd">2. In general the expression `P[x]` compiles to a function with the form `lambda obj: obj[x]`</span>
<span class="sd">3. The class `Lambda` (the class from which the object `P` inherits) overrides most operators to create functions easily. For example, the expression</span>

<span class="sd">    (P * 2) / (P + 1)</span>

<span class="sd">compile to a function of the form</span>

<span class="sd">    f(x) = (x * 2) / (x + 1)</span>

<span class="sd">Check out the documentatio for Phi [lambdas](https://cgarciae.github.io/phi/lambdas.m.html).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable_code</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">iterable_code</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">_reduce_branches</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="p">[])</span>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reduce_branches</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Write</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">branches</span> <span class="o">+</span> <span class="p">[</span> <span class="n">b</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># type(b) is Write</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">branches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">branches</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="n">seq</span> <span class="p">]</span>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">iterable_code</span><span class="p">):</span>

        <span class="n">iterable_code</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable_code</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">iterable_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
            <span class="n">node_f</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_f</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span> <span class="p">]</span>

        <span class="k">return</span> <span class="n">function</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Branch">Branch</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Branch.branches" class="name">var <span class="ident">branches</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Branch.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, iterable_code)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Branch.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Branch.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable_code</span><span class="p">):</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">iterable_code</span> <span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">_reduce_branches</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="p">[])</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.CompilationContextManager" class="name">class <span class="ident">CompilationContextManager</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.CompilationContextManager', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.CompilationContextManager" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CompilationContextManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="n">_NO_VALUE</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_refs</span><span class="p">,</span> <span class="n">next_with_global_context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_refs</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_refs</span> <span class="o">=</span> <span class="n">next_refs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">previous_with_global_context</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_with_global_context</span> <span class="o">=</span> <span class="n">next_with_global_context</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_refs</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_with_global_context</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_refs</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_with_global_context</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="c1">#Copy to avoid stateful behaviour</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">:</span>
            <span class="n">other_ref</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="c1"># merge state: borg pattern</span>
            <span class="n">other_ref</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_ref</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.CompilationContextManager">CompilationContextManager</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="phi.dsl.CompilationContextManager.COMPILATION_GLOBAL_REFS" class="name">var <span class="ident">COMPILATION_GLOBAL_REFS</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.CompilationContextManager.WITH_GLOBAL_CONTEXT" class="name">var <span class="ident">WITH_GLOBAL_CONTEXT</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.CompilationContextManager.next_refs" class="name">var <span class="ident">next_refs</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.CompilationContextManager.next_with_global_context" class="name">var <span class="ident">next_with_global_context</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.CompilationContextManager.previous_refs" class="name">var <span class="ident">previous_refs</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.CompilationContextManager.previous_with_global_context" class="name">var <span class="ident">previous_with_global_context</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.CompilationContextManager.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, next_refs, next_with_global_context)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.CompilationContextManager.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.CompilationContextManager.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_refs</span><span class="p">,</span> <span class="n">next_with_global_context</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">previous_refs</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">next_refs</span> <span class="o">=</span> <span class="n">next_refs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">previous_with_global_context</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">next_with_global_context</span> <span class="o">=</span> <span class="n">next_with_global_context</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="phi.dsl.CompilationContextManager.get_ref">
    <p>def <span class="ident">get_ref</span>(</p><p>cls, name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.CompilationContextManager.get_ref', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.CompilationContextManager.get_ref" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">get_ref</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="phi.dsl.CompilationContextManager.set_ref">
    <p>def <span class="ident">set_ref</span>(</p><p>cls, ref)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.CompilationContextManager.set_ref', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.CompilationContextManager.set_ref" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
    <span class="c1">#Copy to avoid stateful behaviour</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">:</span>
        <span class="n">other_ref</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="c1"># merge state: borg pattern</span>
        <span class="n">other_ref</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">COMPILATION_GLOBAL_REFS</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Composition" class="name">class <span class="ident">Composition</span></p>
      
  
    <div class="desc"><p>In this language tuples are used to express function composition. After compilation, the expression</p>
<div class="codehilite"><pre><span></span>k = (f, g)
</pre></div>


<p>be equivalent to</p>
<div class="codehilite"><pre><span></span>k(x) = g(f(x))
</pre></div>


<p>As you see, its a little different from the mathematical definition. Excecution order flow from left to right, and this makes reading and reasoning about code structured in the way more easy. This bahaviour is based upon the <code>|&gt;</code> (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</p>
<p>In general, the following rules apply after compilation:</p>
<p><strong>General Sequence</strong></p>
<div class="codehilite"><pre><span></span>k = (f0, f1, ..., fn-1, fn)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k(x) = fn(fn-1(...(f1(f0(x)))))
</pre></div>


<p><strong>Single Function</strong></p>
<div class="codehilite"><pre><span></span>k = (f)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k = f
</pre></div>


<p><strong>Identity</strong></p>
<p>The empty tuple</p>
<div class="codehilite"><pre><span></span>k = ()
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k(x) = x
</pre></div>


<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Make</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span> <span class="c1"># ((1 * 2) + 1) ** 2</span>
</pre></div>


<p>As you see, <code>Make</code>s <code>*args</code> are interpreted as a tuple which means all expressions contained are composed. The previous example using <code>P.Pipe</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">9</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">)</span>
</pre></div>


<p>Again, <code>Pipe</code>'s signature is <code>Pipe(x, *args)</code> and <code>*args</code> is interpreted as a tuple which means all expressions contained are composed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Composition', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Composition" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Composition</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">In this language tuples are used to express function composition. After compilation, the expression</span>

<span class="sd">    k = (f, g)</span>

<span class="sd">be equivalent to</span>

<span class="sd">    k(x) = g(f(x))</span>

<span class="sd">As you see, its a little different from the mathematical definition. Excecution order flow from left to right, and this makes reading and reasoning about code structured in the way more easy. This bahaviour is based upon the `|&gt;` (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</span>

<span class="sd">In general, the following rules apply after compilation:</span>

<span class="sd">**General Sequence**</span>

<span class="sd">    k = (f0, f1, ..., fn-1, fn)</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = fn(fn-1(...(f1(f0(x)))))</span>

<span class="sd">**Single Function**</span>

<span class="sd">    k = (f)</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k = f</span>

<span class="sd">**Identity**</span>

<span class="sd">The empty tuple</span>

<span class="sd">    k = ()</span>

<span class="sd">is equivalent to</span>

<span class="sd">    k(x) = x</span>

<span class="sd">### Examples</span>

<span class="sd">    from phi import P</span>

<span class="sd">    f = Make(</span>
<span class="sd">        lambda x: x * 2,</span>
<span class="sd">        lambda x: x + 1,</span>
<span class="sd">        lambda x: x ** 2</span>
<span class="sd">    )</span>

<span class="sd">    assert f(1) == 9 # ((1 * 2) + 1) ** 2</span>

<span class="sd">As you see, `Make`s `*args` are interpreted as a tuple which means all expressions contained are composed. The previous example using `P.Pipe`</span>

<span class="sd">    from phi import P</span>

<span class="sd">    assert 9 == P.Pipe(</span>
<span class="sd">        1,</span>
<span class="sd">        lambda x: x * 2,</span>
<span class="sd">        lambda x: x + 1,</span>
<span class="sd">        lambda x: x ** 2</span>
<span class="sd">    )</span>

<span class="sd">Again, `Pipe`&#39;s signature is `Pipe(x, *args)` and `*args` is interpreted as a tuple which means all expressions contained are composed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_code</span><span class="p">,</span> <span class="n">right_code</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Composition</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">left_code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">right_code</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__build__</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">prevs</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">prevs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Composition</span><span class="o">.</span><span class="n">__build__</span><span class="p">(</span><span class="o">*</span><span class="n">prevs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Composition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">):</span>
        <span class="n">tuple_code</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Identity</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_parse</span><span class="p">(</span><span class="n">tuple_code</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">tuple_code</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Composition</span><span class="o">.</span><span class="n">__build__</span><span class="p">(</span><span class="o">*</span><span class="n">tuple_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="n">f_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compose2</span><span class="p">(</span><span class="n">f_right</span><span class="p">,</span> <span class="n">f_left</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Seq({0}, {1})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Composition">Composition</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Composition.left" class="name">var <span class="ident">left</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.Composition.right" class="name">var <span class="ident">right</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Composition.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, left_code, right_code)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Composition.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Composition.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_code</span><span class="p">,</span> <span class="n">right_code</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Composition</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">left_code</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">right_code</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Function" class="name">class <span class="ident">Function</span></p>
      
  
    <div class="desc"><p>All basic/terminal elements of this language are callables (implement <code>__call__</code>) of arity 1.</p>
<h3>Examples</h3>
<p>Compiling a function just returns back the function</p>
<div class="codehilite"><pre><span></span>Make(f) == f
</pre></div>


<p>and piping through a function is just the same a applying the function</p>
<div class="codehilite"><pre><span></span>P.Pipe(x, f) == f(x)
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Function', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Function" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">All basic/terminal elements of this language are callables (implement `__call__`) of arity 1.</span>

<span class="sd">### Examples</span>
<span class="sd">Compiling a function just returns back the function</span>

<span class="sd">    Make(f) == f</span>

<span class="sd">and piping through a function is just the same a applying the function</span>

<span class="sd">    P.Pipe(x, f) == f(x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_f</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">=</span> <span class="n">_f</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Fun({0})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Function">Function</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Function.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, _f)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Function.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Function.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_f</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">=</span> <span class="n">_f</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.If" class="name">class <span class="ident">If</span></p>
      
  
    <div class="desc"><p>docstring for If.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.If', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.If" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">If</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for If.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">,</span> <span class="o">*</span><span class="n">Then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">Else</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Else&#39;</span><span class="p">,</span> <span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Predicate</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Predicate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Then</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Then</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Else</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Predicate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Predicate</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
        <span class="n">Then</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Then</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
        <span class="n">Else</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Then</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">Predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">Else</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">Else</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">Else</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Else</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.If">If</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.If.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, Predicate, *Then, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.If.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.If.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">,</span> <span class="o">*</span><span class="n">Then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">Else</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Else&#39;</span><span class="p">,</span> <span class="p">())</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_Predicate</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Predicate</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_Then</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Then</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Else</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="phi.dsl.If.Else">
    <p>def <span class="ident">Else</span>(</p><p>self, *Else)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.If.Else', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.If.Else" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Else</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">Else</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_Else</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">Else</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Input" class="name">class <span class="ident">Input</span></p>
      
  
    <div class="desc"><p>Sometimes you might need to branch the computation but start one of the branches with a values different than the one being passed down, you could always solve it like this</p>
<div class="codehilite"><pre><span></span>P.Pipe(
    ...,
    [
        lambda z: my_value
    ,
        ...
    ]
)
</pre></div>


<p>Here we just made a lamda that took in the argument <code>z</code> but it was completely ignored and it always returns <code>my_value</code>, this is called a constant function. You could also do the same with <code>P.Val</code> or the top level function <code>phi.Val</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Val</span>

<span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="o">...</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="n">Val</span><span class="p">(</span><span class="n">my_value</span><span class="p">)</span>
    <span class="p">,</span>
        <span class="o">...</span>
    <span class="p">]</span>
<span class="p">)</span><span class="o">|</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Input', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Input" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Input</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sometimes you might need to branch the computation but start one of the branches with a values different than the one being passed down, you could always solve it like this</span>

<span class="sd">    P.Pipe(</span>
<span class="sd">        ...,</span>
<span class="sd">        [</span>
<span class="sd">            lambda z: my_value</span>
<span class="sd">        ,</span>
<span class="sd">            ...</span>
<span class="sd">        ]</span>
<span class="sd">    )</span>

<span class="sd">Here we just made a lamda that took in the argument `z` but it was completely ignored and it always returns `my_value`, this is called a constant function. You could also do the same with `P.Val` or the top level function `phi.Val`</span>

<span class="sd">    from phi import P, Val</span>

<span class="sd">    P.Pipe(</span>
<span class="sd">        ...,</span>
<span class="sd">        [</span>
<span class="sd">            Val(my_value)</span>
<span class="sd">        ,</span>
<span class="sd">            ...</span>
<span class="sd">        ]</span>
<span class="sd">    )|</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">f</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Input">Input</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Input.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Input.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, value)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Input.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Input.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Node" class="name">class <span class="ident">Node</span></p>
      
  
    <div class="desc"><p>docstring for Node.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Node', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Node" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for Node.&quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Read" class="name">class <span class="ident">Read</span></p>
      
  
    <div class="desc"><p>Giving names and saving parts of your computation to use then latter is useful to say the least. In the DSL the expression</p>
<div class="codehilite"><pre><span></span>{&#39;x&#39;}
</pre></div>


<p>behaves like just like the indentity except that as a side effect it creates a reference to that value which you can call latter. Here <code>{..}</code> is python's sytax for a set literal and <code>x</code> is a string with the name of the reference. To read the previous you would use the expression</p>
<div class="codehilite"><pre><span></span>&#39;x&#39;
</pre></div>


<p>This is equivalent to a sort of function like this</p>
<div class="codehilite"><pre><span></span>lambda z: read(&#39;x&#39;)
</pre></div>


<p>where the input is totally ignored and a hypothetical <code>read</code> function is given the reference name and it should return its stored value (internally its not implemented like this). As you see strings in the DSL mean read from a reference and a set with a string means write to a reference.</p>
<h3>Example</h3>
<p>Lets see a common situation where you would use this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span>
    <span class="n">fun_1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;fun_1_val&#39;</span><span class="p">}</span>
    <span class="n">fun_2</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="n">fun_4</span>
    <span class="p">,</span>
    <span class="p">(</span>
        <span class="s1">&#39;fun_1_val&#39;</span><span class="p">,</span>
        <span class="n">fun_5</span>
    <span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>


<p>Here you <em>save</em> the value outputed by <code>fun_1</code> and the load it as the initial value of the second branch. In normal python the previous would be <em>almost</em> equivalent to this</p>
<div class="codehilite"><pre><span></span>x = fun_1(input)
fun_1_val = x
x = fun_2(x)
x = [
    fun_4(x)
,
    fun_5(fun_1_val)
]

return x
</pre></div>


<h3>Write special case</h3>
<p>When composing its aesthetically better to put writes in the same line as the function whos value its storing to make the intent a bit more clear:</p>
<div class="codehilite"><pre><span></span>(
    f, {&#39;a&#39;},
    g
)
</pre></div>


<p>Here we store the value of <code>f</code> in <code>'a'</code>, however, when you are inside a branch you will be tempted to do the following to get the same result:</p>
<div class="codehilite"><pre><span></span>[
    f, {&#39;a&#39;}
,
    g
]
</pre></div>


<p>However, if you flatten the text you realize you actually have 3 branches instead of 2</p>
<div class="codehilite"><pre><span></span>[ f, {&#39;a&#39;}, g ]
</pre></div>


<p>and that wont save the value of <code>f</code> in <code>'a'</code> as you intended. To avoid this possible error, the DSL rewrites the expression during parsing to</p>
<div class="codehilite"><pre><span></span>[ ( f, {&#39;a&#39;} ), g ]
</pre></div>


<p>every time there is a write expression inside a branch expression.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Read', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Read" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Read</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Giving names and saving parts of your computation to use then latter is useful to say the least. In the DSL the expression</span>

<span class="sd">    {&#39;x&#39;}</span>

<span class="sd">behaves like just like the indentity except that as a side effect it creates a reference to that value which you can call latter. Here `{..}` is python&#39;s sytax for a set literal and `x` is a string with the name of the reference. To read the previous you would use the expression</span>

<span class="sd">    &#39;x&#39;</span>

<span class="sd">This is equivalent to a sort of function like this</span>

<span class="sd">    lambda z: read(&#39;x&#39;)</span>

<span class="sd">where the input is totally ignored and a hypothetical `read` function is given the reference name and it should return its stored value (internally its not implemented like this). As you see strings in the DSL mean read from a reference and a set with a string means write to a reference.</span>

<span class="sd">### Example</span>
<span class="sd">Lets see a common situation where you would use this</span>

<span class="sd">    from phi import P</span>

<span class="sd">    P.Pipe(</span>
<span class="sd">        input,</span>
<span class="sd">        fun_1, {&#39;fun_1_val&#39;}</span>
<span class="sd">        fun_2,</span>
<span class="sd">        [</span>
<span class="sd">            fun_4</span>
<span class="sd">        ,</span>
<span class="sd">        (</span>
<span class="sd">            &#39;fun_1_val&#39;,</span>
<span class="sd">            fun_5</span>
<span class="sd">        )</span>
<span class="sd">        ]</span>
<span class="sd">    )</span>

<span class="sd">Here you *save* the value outputed by `fun_1` and the load it as the initial value of the second branch. In normal python the previous would be *almost* equivalent to this</span>

<span class="sd">    x = fun_1(input)</span>
<span class="sd">    fun_1_val = x</span>
<span class="sd">    x = fun_2(x)</span>
<span class="sd">    x = [</span>
<span class="sd">        fun_4(x)</span>
<span class="sd">    ,</span>
<span class="sd">        fun_5(fun_1_val)</span>
<span class="sd">    ]</span>

<span class="sd">    return x</span>

<span class="sd">### Write special case</span>
<span class="sd">When composing its aesthetically better to put writes in the same line as the function whos value its storing to make the intent a bit more clear:</span>

<span class="sd">    (</span>
<span class="sd">        f, {&#39;a&#39;},</span>
<span class="sd">        g</span>
<span class="sd">    )</span>

<span class="sd">Here we store the value of `f` in `&#39;a&#39;`, however, when you are inside a branch you will be tempted to do the following to get the same result:</span>

<span class="sd">    [</span>
<span class="sd">        f, {&#39;a&#39;}</span>
<span class="sd">    ,</span>
<span class="sd">        g</span>
<span class="sd">    ]</span>

<span class="sd">However, if you flatten the text you realize you actually have 3 branches instead of 2</span>

<span class="sd">    [ f, {&#39;a&#39;}, g ]</span>

<span class="sd">and that wont save the value of `f` in `&#39;a&#39;` as you intended. To avoid this possible error, the DSL rewrites the expression during parsing to</span>

<span class="sd">    [ ( f, {&#39;a&#39;} ), g ]</span>

<span class="sd">every time there is a write expression inside a branch expression.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Read</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">get_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">f</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Read">Read</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Read.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Read.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Read.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Read.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Read</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Record" class="name">class <span class="ident">Record</span></p>
      
  
    <div class="desc"><p>List or iterables in general provide you a way to branch your computation in the DSL, but access to the values of each branch are then done by index, this might be a little inconvenient because it reduces readability. Record branches provide a way to create named branches via a dictionary object where the keys are the names of the branches and the values are valid expressions representing the computation of that branch.</p>
<p>A special object is returned by this expression when excecuted, this object derives from <code>dict</code> and fully emulates it so you can treat it as such, however it also implements the <code>__getattr__</code> method, this lets you access a value as if it where a field if its key is a of type string.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">stats</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span>
    <span class="p">,</span>
        <span class="nb">len</span> <span class="o">=</span> <span class="nb">len</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">stats</span><span class="o">.</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">6</span>
<span class="k">assert</span> <span class="n">stats</span><span class="o">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">3</span>

<span class="k">assert</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span>
<span class="k">assert</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>


<p>Now lets image that we want to find the average value of the list, we could calculate it outside of the pipe doing something like <code>avg = stats.sum / stats.len</code>, however we could also do it inside the pipe using <code>P.Rec</code> or <code>phi.Rec</code> like this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Rec</span>

<span class="n">avg</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span>
    <span class="p">,</span>
        <span class="nb">len</span> <span class="o">=</span> <span class="nb">len</span>
    <span class="p">),</span>
    <span class="n">Rec</span><span class="o">.</span><span class="n">sum</span> <span class="o">/</span> <span class="n">Rec</span><span class="o">.</span><span class="n">len</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Record', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Record" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Record</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">List or iterables in general provide you a way to branch your computation in the DSL, but access to the values of each branch are then done by index, this might be a little inconvenient because it reduces readability. Record branches provide a way to create named branches via a dictionary object where the keys are the names of the branches and the values are valid expressions representing the computation of that branch.</span>

<span class="sd">A special object is returned by this expression when excecuted, this object derives from `dict` and fully emulates it so you can treat it as such, however it also implements the `__getattr__` method, this lets you access a value as if it where a field if its key is a of type string.</span>

<span class="sd">### Examples</span>

<span class="sd">    from phi import P</span>

<span class="sd">    stats = P.Pipe(</span>
<span class="sd">        [1,2,3],</span>
<span class="sd">        dict(</span>
<span class="sd">            sum = sum</span>
<span class="sd">        ,</span>
<span class="sd">            len = len</span>
<span class="sd">        )</span>
<span class="sd">    )</span>

<span class="sd">    assert stats.sum == 6</span>
<span class="sd">    assert stats.len == 3</span>

<span class="sd">    assert stats[&#39;sum&#39;] == 6</span>
<span class="sd">    assert stats[&#39;len&#39;] == 3</span>

<span class="sd">Now lets image that we want to find the average value of the list, we could calculate it outside of the pipe doing something like `avg = stats.sum / stats.len`, however we could also do it inside the pipe using `P.Rec` or `phi.Rec` like this</span>

<span class="sd">    from phi import P, Rec</span>

<span class="sd">    avg = P.Pipe(</span>
<span class="sd">        [1,2,3],</span>
<span class="sd">        dict(</span>
<span class="sd">            sum = sum</span>
<span class="sd">        ,</span>
<span class="sd">            len = len</span>
<span class="sd">        ),</span>
<span class="sd">        Rec.sum / Rec.len</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_code</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Record</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">dict_code</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">dict_code</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Record</span><span class="p">(</span><span class="n">dict_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">funs_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

            <span class="n">funs_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_RecordObject</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">})</span>

        <span class="k">return</span> <span class="n">function</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Record">Record</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Record.nodes_dict" class="name">var <span class="ident">nodes_dict</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Record.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, dict_code)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Record.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Record.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_code</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Record</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">dict_code</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Ref" class="name">class <span class="ident">Ref</span></p>
      
  
    <div class="desc"><p>docstring for Ref.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Ref', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Ref" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Ref</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for Ref.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">_NO_VALUE</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Ref</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">optional</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">_NO_VALUE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Trying to read Ref(&#39;{0}&#39;) before assignment&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">x</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Ref">Ref</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Ref.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.Ref.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Ref.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, value=NoValue)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Ref.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Ref.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">_NO_VALUE</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Ref</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="phi.dsl.Ref.set">
    <p>def <span class="ident">set</span>(</p><p>self, x)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Ref.set', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Ref.set" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.With" class="name">class <span class="ident">With</span></p>
      
  
    <div class="desc"><p><strong>With</strong></p>
<div class="codehilite"><pre><span></span>def With(context_manager, *body):
</pre></div>


<p><strong>Arguments</strong></p>
<ul>
<li><strong>context_manager</strong>: a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> object or valid expression from the DSL that returns a context manager.</li>
<li><strong>*body</strong>: any valid expression of the DSL to be evaluated inside the context. <code>*body</code> is interpreted as a tuple so all expression contained are composed.</li>
</ul>
<p>As with normal python programs you sometimes might want to create a context for a block of code. You normally give a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> to the <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement">with</a> statemente, in Phi you use <code>P.With</code> or <code>phi.With</code></p>
<p><strong>Context</strong></p>
<p>Python's <code>with</code> statemente returns a context object through <code>as</code> keyword, in the DSL this object can be obtained using the <code>P.Context</code> method or the <code>phi.Context</code> function.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">With</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">text</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>The previous is equivalent to</p>
<div class="codehilite"><pre><span></span>with open(&quot;text.txt&quot;) as f:
    text = f.read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.With', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.With" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">With</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**With**</span>

<span class="sd">    def With(context_manager, *body):</span>

<span class="sd">**Arguments**</span>

<span class="sd">* **context_manager**: a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) object or valid expression from the DSL that returns a context manager.</span>
<span class="sd">* ***body**: any valid expression of the DSL to be evaluated inside the context. `*body` is interpreted as a tuple so all expression contained are composed.</span>

<span class="sd">As with normal python programs you sometimes might want to create a context for a block of code. You normally give a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) to the [with](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement) statemente, in Phi you use `P.With` or `phi.With`</span>

<span class="sd">**Context**</span>

<span class="sd">Python&#39;s `with` statemente returns a context object through `as` keyword, in the DSL this object can be obtained using the `P.Context` method or the `phi.Context` function.</span>

<span class="sd">### Examples</span>

<span class="sd">    from phi import P, Obj, Context, With, Pipe</span>

<span class="sd">    text = Pipe(</span>
<span class="sd">        &quot;text.txt&quot;,</span>
<span class="sd">        With( open, Context,</span>
<span class="sd">            Obj.read()</span>
<span class="sd">        )</span>
<span class="sd">    )</span>

<span class="sd">The previous is equivalent to</span>

<span class="sd">    with open(&quot;text.txt&quot;) as f:</span>
<span class="sd">        text = f.read()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope_code</span><span class="p">,</span> <span class="o">*</span><span class="n">body_code</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">With</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">scope_code</span><span class="p">,</span> <span class="n">else_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">body_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">scope_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>
        <span class="n">body_fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">__compile__</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">scope_f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">as</span> <span class="n">scope</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">body_fs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">function</span>

    <span class="k">def</span> <span class="nf">set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_scope</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span> <span class="o">=</span> <span class="n">new_scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_scope</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_scope</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.With">With</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.With.body" class="name">var <span class="ident">body</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="phi.dsl.With.scope" class="name">var <span class="ident">scope</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.With.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, scope_code, *body_code)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.With.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.With.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope_code</span><span class="p">,</span> <span class="o">*</span><span class="n">body_code</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">With</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">scope_code</span><span class="p">,</span> <span class="n">else_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">body_code</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="phi.dsl.With.set_scope">
    <p>def <span class="ident">set_scope</span>(</p><p>self, new_scope)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.With.set_scope', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.With.set_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_scope</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span> <span class="o">=</span> <span class="n">new_scope</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">old_scope</span> <span class="o">=</span> <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="phi.dsl.Write" class="name">class <span class="ident">Write</span></p>
      
  
    <div class="desc"><p>Giving names and saving parts of your computation to use then latter is useful to say the least. In the DSL the expression</p>
<div class="codehilite"><pre><span></span>{&#39;x&#39;}
</pre></div>


<p>behaves like just like the indentity except that as a side effect it creates a reference to that value which you can call latter. Here <code>{..}</code> is python's sytax for a set literal and <code>x</code> is a string with the name of the reference. To read the previous you would use the expression</p>
<div class="codehilite"><pre><span></span>&#39;x&#39;
</pre></div>


<p>This is equivalent to a sort of function like this</p>
<div class="codehilite"><pre><span></span>lambda z: read(&#39;x&#39;)
</pre></div>


<p>where the input is totally ignored and a hypothetical <code>read</code> function is given the reference name and it should return its stored value (internally its not implemented like this). As you see strings in the DSL mean read from a reference and a set with a string means write to a reference.</p>
<h3>Example</h3>
<p>Lets see a common situation where you would use this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span>
    <span class="n">fun_1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;fun_1_val&#39;</span><span class="p">}</span>
    <span class="n">fun_2</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="n">fun_4</span>
    <span class="p">,</span>
    <span class="p">(</span>
        <span class="s1">&#39;fun_1_val&#39;</span><span class="p">,</span>
        <span class="n">fun_5</span>
    <span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>


<p>Here you <em>save</em> the value outputed by <code>fun_1</code> and the load it as the initial value of the second branch. In normal python the previous would be <em>almost</em> equivalent to this</p>
<div class="codehilite"><pre><span></span>x = fun_1(input)
fun_1_val = x
x = fun_2(x)
x = [
    fun_4(x)
,
    fun_5(fun_1_val)
]

return x
</pre></div>


<h3>Write special case</h3>
<p>When composing its aesthetically better to put writes in the same line as the function whos value its storing to make the intent a bit more clear:</p>
<div class="codehilite"><pre><span></span>(
    f, {&#39;a&#39;},
    g
)
</pre></div>


<p>Here we store the value of <code>f</code> in <code>'a'</code>, however, when you are inside a branch you will be tempted to do the following to get the same result:</p>
<div class="codehilite"><pre><span></span>[
    f, {&#39;a&#39;}
,
    g
]
</pre></div>


<p>However, if you flatten the text you realize you actually have 3 branches instead of 2</p>
<div class="codehilite"><pre><span></span>[ f, {&#39;a&#39;}, g ]
</pre></div>


<p>and that wont save the value of <code>f</code> in <code>'a'</code> as you intended. To avoid this possible error, the DSL rewrites the expression during parsing to</p>
<div class="codehilite"><pre><span></span>[ ( f, {&#39;a&#39;} ), g ]
</pre></div>


<p>every time there is a write expression inside a branch expression.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Write', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Write" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Write</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="n">Read</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Write</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__parse__</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Identity</span>

        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">code</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Ref</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parse Error: Sets can only contain strings or Refs, get {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>

        <span class="n">writes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">Write</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">code</span> <span class="p">])</span>
        <span class="k">return</span> <span class="n">_parse</span><span class="p">(</span><span class="n">writes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compile__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">Ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span>

            <span class="n">ref</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">CompilationContextManager</span><span class="o">.</span><span class="n">set_ref</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">f</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#phi.dsl.Write">Write</a></li>
          <li><a href="#phi.dsl.Node">Node</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="phi.dsl.Write.ref" class="name">var <span class="ident">ref</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="phi.dsl.Write.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, ref)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-phi.dsl.Write.__init__', this);">Show source &equiv;</a></p>
  <div id="source-phi.dsl.Write.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Write</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
